{-# LANGUAGE TypeFamilies, RankNTypes #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE GADTs #-}

{-|
Note [CSE for Stg]
~~~~~~~~~~~~~~~~~~
This module implements a simple common subexpression elimination pass for STG.
This is useful because there are expressions that we want to common up (because
they are operationally equivalent), but that we cannot common up in Core, because
their types differ.
This was originally reported as #9291.

There are two types of common code occurrences that we aim for, see
note [Case 1: CSEing allocated closures] and
note [Case 2: CSEing case binders] below.


Note [Case 1: CSEing allocated closures]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The first kind of CSE opportunity we aim for is generated by this Haskell code:

    bar :: a -> (Either Int a, Either Bool a)
    bar x = (Right x, Right x)

which produces this Core:

    bar :: forall a. a -> (Either Int a, Either Bool a)
    bar @a x = (Right @Int @a x, Right @Bool @a x)

where the two components of the tuple are different terms, and cannot be
commoned up (easily). On the STG level we have

    bar [x] = let c1 = Right [x]
                  c2 = Right [x]
              in (c1,c2)

and now it is obvious that we can write

    bar [x] = let c1 = Right [x]
              in (c1,c1)

instead.


Note [Case 2: CSEing case binders]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The second kind of CSE opportunity we aim for is more interesting, and
came up in #9291 and #5344: The Haskell code

    foo :: Either Int a -> Either Bool a
    foo (Right x) = Right x
    foo _         = Left False

produces this Core

    foo :: forall a. Either Int a -> Either Bool a
    foo @a e = case e of b { Left n -> …
                           , Right x -> Right @Bool @a x }

where we cannot CSE `Right @Bool @a x` with the case binder `b` as they have
different types. But in STG we have

    foo [e] = case e of b { Left [n] -> …
                          , Right [x] -> Right [x] }

and nothing stops us from transforming that to

    foo [e] = case e of b { Left [n] -> …
                          , Right [x] -> b}


Note [StgCse after unarisation]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider two unboxed sum terms:

    (# 1 | #) :: (# Int | Int# #)
    (# 1 | #) :: (# Int | Int  #)

These two terms are not equal as they unarise to different unboxed
tuples. However if we run StgCse before Unarise, it'll think the two
terms (# 1 | #) are equal, and replace one of these with a binder to
the other. That's bad -- #15300.

Solution: do unarise first.

-}

module StgAnal (stgAna) where

import GhcPrelude

import DataCon
import Data.Bifunctor
import Id
import StgSyn
import Outputable
import VarEnv
import CoreSyn (AltCon(..))
import Data.List (mapAccumL)
import Data.Maybe (fromMaybe)
import CoreMap
import NameEnv
import Control.Monad( (>=>) )
import VarSet

import Hoopl.Collections
import PrimOp

emptyEnv :: IdSet
emptyEnv = emptyVarSet

stgAna :: [CgStgTopBinding] -> [CgStgTopBinding]
stgAna = map anaTopBind

anaTopBind :: CgStgTopBinding -> CgStgTopBinding
anaTopBind lit@StgTopStringLit {} = lit
anaTopBind (StgTopLifted bind) =
    StgTopLifted $ anaBind emptyEnv bind

anaBind :: IdSet -> CgStgBinding -> CgStgBinding
anaBind env (StgNonRec v rhs) =
    StgNonRec v $ anaRhs env rhs
anaBind env (StgRec binds) =
    StgRec $ map (second (anaRhs env)) binds

anaRhs :: IdSet -> CgStgRhs -> CgStgRhs
anaRhs _env e@(StgRhsCon {}) = e -- TODO: Strict fields
anaRhs env (StgRhsClosure _ext _ccs _flag _args body)
    = StgRhsClosure _ext _ccs _flag _args $
        anaExpr env body

-- We keep a set of already evaluated ids.
anaExpr :: IdSet -> CgStgExpr -> CgStgExpr
anaExpr env (e@StgCase {}) = anaCase env e
anaExpr env (e@StgLet {}) = anaLet env e
anaExpr env (e@StgLetNoEscape {}) = anaLetNoEscape env e
anaExpr env (StgTick t e) = StgTick t $ anaExpr env e

anaExpr _env e@(StgApp _ _f _args) = e
anaExpr _env e@(StgLit _lit) = e
anaExpr _env e@(StgConApp _con _args _tys) = e
anaExpr _env e@(StgOpApp _op _args _ty) = e
anaExpr _env e@(StgLam {}) = error "Invariant violated: No lambdas in finalized STG representation."


anaCase :: IdSet -> CgStgExpr -> CgStgExpr
anaCase env (StgCase scrut bndr _ty alts) =
    pprTrace "anaCase:" (text "scrut" <+> ppr scrut $$ text "env'" <+> ppr env' $$
        text "env" <+> ppr env $$ text "redundant" <+> ppr redundantEvaled) $
    (StgCase scrut' bndr _ty alts')
  where
    alts' = map (anaAlt env') alts
    scrut'
        | StgApp _ v [] <- scrut
        , elemVarSet v env
        =
            pprTrace "Marking:" (ppr v) $
            StgApp MarkedStrict v []
        | otherwise = scrut


    redundantEvaled = filter (`elemVarSet` env) scrutEvaledBinds

    env' = (extendVarSetList env scrutStrictGuaranteed)
    scrutEvaledBinds
        | StgApp _ v [] <- scrut = [v]
        | otherwise = []
    scrutStrictGuaranteed
        | StgApp _ v [] <- scrut
        = [v, bndr]
        | StgConApp dcon args _ty <- scrut
        = let   strictSigs = dataConRepStrictness dcon
                strictArgs = filterWith isMarkedStrict args strictSigs
          in bndr:[v | StgVarArg v <- strictArgs ]
        -- | StgOpApp (StgPrimOp op ) args _ty <- scrut
        -- = let   (_,_,_,_,strictSigs) = primOpSig op
        --         strictArgs = filterWith isMarkedStrict args strictSigs
        --   in [v | StgVarArg v <- strictArgs ]
        | otherwise = []

anaCase _ _ = error "Not a case"

anaAlt :: IdSet -> CgStgAlt -> CgStgAlt
anaAlt env (con, binds, rhs)
    | DataAlt dcon <- con
    = let   strictSigs = dataConRepStrictness dcon
            strictBinds = filterWith isMarkedStrict binds strictSigs
            env' = extendVarSetList env strictBinds
      in (con, binds, anaExpr env' rhs)
    | otherwise = (con, binds, anaExpr env rhs)

anaLet env (StgLet ext bind body)
    = StgLet ext (anaBind env bind) (anaExpr env body)
anaLet _ _ = error "Not a Let"

-- TODO: If body evaluates a var it should be treated evaluated
-- in the the binding.
anaLetNoEscape env (StgLetNoEscape ext bind body)
    = StgLetNoEscape ext (anaBind env bind) (anaExpr env body)
anaLetNoEscape _ _ = error "Not a LetNoEscape"


-- stgAna :: [StgTopBinding] -> [Id]
-- stgAna = concatMap anaTopBind

-- anaTopBind :: StgTopBinding -> [Id]
-- anaTopBind StgTopStringLit {} = []
-- anaTopBind (StgTopLifted bind) =
--     anaBind emptyEnv bind

-- anaBind :: IdSet -> StgBinding -> [Id]
-- anaBind env (StgNonRec _v rhs) =
--     anaRhs env rhs
-- anaBind env (StgRec binds) =
--     concatMap (anaRhs env) $ map snd binds

-- anaRhs :: IdSet -> StgRhs -> [Id]
-- anaRhs _env (StgRhsCon {}) = [] -- TODO: Strict fields
-- anaRhs env  (StgRhsClosure _ext _ccs _flag _args body)
--     = anaExpr env body

-- -- We keep a set of already evaluated ids.
-- anaExpr :: IdSet -> StgExpr -> [Id]
-- anaExpr _env (StgApp _ _f _args) = []
-- anaExpr _env (StgLit _lit) = []
-- anaExpr _env (StgConApp _con _args _tys) = []
-- anaExpr _env (StgOpApp _op _args _ty) = []
-- anaExpr _env (StgLam {}) = error "Invariant violated: No lambdas in finalized STG representation."
-- anaExpr env (e@StgCase {}) = anaCase env e
-- anaExpr env (e@StgLet {}) = anaLet env e
-- anaExpr env (e@StgLetNoEscape {}) = anaLetNoEscape env e
-- anaExpr env (StgTick _ e) = anaExpr env e

-- anaCase :: IdSet -> StgExpr -> [Id]
-- anaCase env (StgCase scrut bndr _ty alts) =
--     redundantEvaled ++ altResults
--   where
--     altResults = concatMap (anaAlt env') alts
--     redundantEvaled = filter (`elemVarSet` env) scrutEvaledBinds

--     env' = (extendVarSetList env scrutStrictGuaranteed)
--     scrutEvaledBinds
--         | StgApp _ v [] <- scrut = [v]
--         | otherwise = []
--     scrutStrictGuaranteed
--         | StgApp _ v [] <- scrut
--         = [v]
--         | StgConApp dcon args _ty <- scrut
--         = let   strictSigs = dataConRepStrictness dcon
--                 strictArgs = filterWith isMarkedStrict args strictSigs
--           in [v | StgVarArg v <- strictArgs ]
--         -- | StgOpApp (StgPrimOp op ) args _ty <- scrut
--         -- = let   (_,_,_,_,strictSigs) = primOpSig op
--         --         strictArgs = filterWith isMarkedStrict args strictSigs
--         --   in [v | StgVarArg v <- strictArgs ]
--         | otherwise = []

-- anaCase _ _ = error "Not a case"



-- anaAlt :: IdSet -> StgAlt -> [Id]
-- anaAlt env (con, binds, rhs)
--     | DataAlt dcon <- con
--     = let   strictSigs = dataConRepStrictness dcon
--             strictBinds = filterWith isMarkedStrict binds strictSigs
--             env' = extendVarSetList env strictBinds
--       in anaExpr env' rhs
--     | otherwise = anaExpr env rhs

-- anaLet env (StgLet _ bind body)
--     = anaBind env bind ++ anaExpr env body
-- anaLet _ _ = error "Not a Let"

-- anaLetNoEscape env (StgLetNoEscape _ bind body)
--     = anaBind env bind ++ anaExpr env body
-- anaLetNoEscape _ _ = error "Not a LetNoEscape"

-- | Keep elements from a if f returns true for the matching element in bs
filterWith :: (b -> Bool) -> [a] -> [b] -> [a]
filterWith f xs ys = map fst . filter (f . snd) $ zip xs ys



-- exprIsBndr :: StgExpr -> Maybe Id
-- exprIsBndr